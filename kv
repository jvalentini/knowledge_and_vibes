#!/usr/bin/env bash
#
# kv - knowledge_and_vibes CLI
# A clean TUI for the AI Coding Agent Toolkit
#
# Design inspired by lazygit, lazydocker, and charmbracelet/gum
#

# ─────────────────────────────────────────────────────────────────────────────
# Colors (minimal palette)
# ─────────────────────────────────────────────────────────────────────────────
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'
C_CYAN='\033[36m'
C_GREEN='\033[32m'
C_YELLOW='\033[33m'
C_RED='\033[31m'
C_WHITE='\033[97m'
C_BG_CYAN='\033[46m'
C_BLACK='\033[30m'

# ─────────────────────────────────────────────────────────────────────────────
# State
# ─────────────────────────────────────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION="1.0.0"

# KV_HOME is where the docs live - set during install or use default
KV_HOME="${KV_HOME:-/Users/burdo/Desktop/knowledge_and_vibes}"

# Check tool installation status (cached for speed)
check_tools() {
    HAS_BD=$(command -v bd &>/dev/null && echo 1 || echo 0)
    HAS_BV=$(command -v bv &>/dev/null && echo 1 || echo 0)
    HAS_CASS=$(command -v cass &>/dev/null && echo 1 || echo 0)
    HAS_UBS=$(command -v ubs &>/dev/null && echo 1 || echo 0)
    AM_RUNNING=$(curl -s --connect-timeout 1 http://127.0.0.1:8765/health &>/dev/null && echo 1 || echo 0)
    HAS_BEADS_DIR=$([ -d ".beads" ] && echo 1 || echo 0)
}

# ─────────────────────────────────────────────────────────────────────────────
# Drawing helpers
# ─────────────────────────────────────────────────────────────────────────────
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)
TERM_HEIGHT=$(tput lines 2>/dev/null || echo 24)
[ "$TERM_WIDTH" -gt 100 ] && TERM_WIDTH=100

# Draw horizontal line
hline() {
    local width=${1:-$TERM_WIDTH}
    printf '%*s' "$width" '' | tr ' ' '─'
}

# Status indicator
status_dot() {
    if [ "$1" = "1" ]; then
        printf "${C_GREEN}●${C_RESET}"
    else
        printf "${C_DIM}○${C_RESET}"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# UI Components
# ─────────────────────────────────────────────────────────────────────────────
draw_header() {
    echo ""
    printf "${C_BOLD}${C_CYAN}knowledge_and_vibes${C_RESET}\n"
    printf "${C_DIM}────────────────────────────────────${C_RESET}\n"
}

draw_status_bar() {
    local hint="$1"
    printf "\n${C_DIM}"
    hline
    printf "\n ${C_CYAN}↑↓${C_DIM} navigate  ${C_CYAN}enter${C_DIM} select  ${C_CYAN}q${C_DIM} quit"
    [ -n "$hint" ] && printf "  │  $hint"
    printf "${C_RESET}\n"
}

# ─────────────────────────────────────────────────────────────────────────────
# Main Menu
# ─────────────────────────────────────────────────────────────────────────────
show_main_menu() {
    check_tools
    draw_header

    # Count installed
    local installed=0
    [ "$HAS_BD" = "1" ] && ((installed++))
    [ "$HAS_BV" = "1" ] && ((installed++))
    [ "$HAS_CASS" = "1" ] && ((installed++))
    [ "$HAS_UBS" = "1" ] && ((installed++))

    printf "\n"
    printf " ${C_BOLD}${C_WHITE}AI Coding Agent Toolkit${C_RESET}  ${C_DIM}v${VERSION}${C_RESET}\n"
    printf " ${C_DIM}$installed/4 tools installed${C_RESET}\n"
    printf "\n"

    # Menu with inline status
    printf " ${C_DIM}──────────────────────────────────────${C_RESET}\n"
    printf "\n"
    printf "  ${C_CYAN}i${C_RESET}  Install tools\n"
    printf "  ${C_CYAN}u${C_RESET}  Update            ${C_DIM}pull latest & reinstall${C_RESET}\n"
    printf "  ${C_CYAN}s${C_RESET}  Status            "
    [ "$installed" -eq 4 ] && printf "${C_GREEN}all installed${C_RESET}\n" || printf "${C_YELLOW}$installed/4${C_RESET}\n"
    printf "  ${C_CYAN}t${C_RESET}  Tutorial\n"
    printf "  ${C_CYAN}a${C_RESET}  Create AGENTS.md  "
    [ -f "AGENTS.md" ] && printf "${C_DIM}exists${C_RESET}\n" || printf "${C_DIM}not found${C_RESET}\n"
    printf "  ${C_CYAN}d${C_RESET}  Documentation\n"
    printf "\n"
    printf " ${C_DIM}──────────────────────────────────────${C_RESET}\n"
    printf "\n"
    printf "  ${C_CYAN}q${C_RESET}  Quit\n"

    draw_status_bar ""
}

# ─────────────────────────────────────────────────────────────────────────────
# Status View
# ─────────────────────────────────────────────────────────────────────────────
show_status() {
    check_tools
    draw_header

    printf "\n"
    printf " ${C_BOLD}${C_WHITE}Installation Status${C_RESET}\n"
    printf "\n"

    printf " ${C_DIM}CLI Tools${C_RESET}\n"
    printf "  $(status_dot $HAS_BD)  Beads (bd)         "
    [ "$HAS_BD" = "1" ] && printf "${C_DIM}$(which bd)${C_RESET}\n" || printf "${C_RED}not installed${C_RESET}\n"

    printf "  $(status_dot $HAS_BV)  Beads Viewer (bv)  "
    [ "$HAS_BV" = "1" ] && printf "${C_DIM}$(which bv)${C_RESET}\n" || printf "${C_RED}not installed${C_RESET}\n"

    printf "  $(status_dot $HAS_CASS)  CASS (cass)        "
    [ "$HAS_CASS" = "1" ] && printf "${C_DIM}$(which cass)${C_RESET}\n" || printf "${C_RED}not installed${C_RESET}\n"

    printf "  $(status_dot $HAS_UBS)  UBS (ubs)          "
    [ "$HAS_UBS" = "1" ] && printf "${C_DIM}$(which ubs)${C_RESET}\n" || printf "${C_RED}not installed${C_RESET}\n"

    printf "\n"
    printf " ${C_DIM}Services${C_RESET}\n"
    printf "  $(status_dot $AM_RUNNING)  Agent Mail         "
    [ "$AM_RUNNING" = "1" ] && printf "${C_GREEN}running${C_DIM} :8765${C_RESET}\n" || printf "${C_YELLOW}stopped${C_DIM} (start: am)${C_RESET}\n"

    printf "\n"
    printf " ${C_DIM}Project${C_RESET}\n"
    printf "  $(status_dot $HAS_BEADS_DIR)  .beads/            "
    [ "$HAS_BEADS_DIR" = "1" ] && printf "${C_GREEN}initialized${C_RESET}\n" || printf "${C_DIM}run: bd init${C_RESET}\n"

    draw_status_bar "${C_CYAN}b${C_DIM} back"

    read -rsn1 key
    case "$key" in
        b|B|q|Q) return ;;
        *) show_status ;;
    esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Install Menu
# ─────────────────────────────────────────────────────────────────────────────
show_install_menu() {
    check_tools
    draw_header

    printf "\n"
    printf " ${C_BOLD}${C_WHITE}Install${C_RESET}\n"
    printf "\n"

    printf "  ${C_CYAN}1${C_RESET}  Full stack         ${C_DIM}All tools below${C_RESET}\n"
    printf "  ${C_CYAN}2${C_RESET}  Core only          ${C_DIM}Beads + Viewer + Agent Mail${C_RESET}\n"
    printf "  ${C_CYAN}3${C_RESET}  CASS               ${C_DIM}Session search${C_RESET}\n"
    printf "  ${C_CYAN}4${C_RESET}  UBS                ${C_DIM}Bug scanner${C_RESET}\n"
    printf "  ${C_CYAN}5${C_RESET}  Warp-Grep          ${C_DIM}Parallel search MCP${C_RESET}\n"
    printf "  ${C_CYAN}6${C_RESET}  Exa MCP            ${C_DIM}AI web/code search${C_RESET}\n"
    printf "  ${C_CYAN}7${C_RESET}  cass-memory        ${C_DIM}Cross-agent learning${C_RESET}\n"
    printf "\n"
    printf " ${C_DIM}──────────────────────────────────────${C_RESET}\n"
    printf "\n"
    printf "  ${C_CYAN}p${C_RESET}  Initialize project ${C_DIM}bd init${C_RESET}\n"

    draw_status_bar "${C_CYAN}b${C_DIM} back"

    read -rsn1 key
    case "$key" in
        1) run_install_full ;;
        2) run_install_core ;;
        3) run_install_cass ;;
        4) run_install_ubs ;;
        5) run_install_warpgrep ;;
        6) run_install_exa ;;
        7) run_install_cass_memory ;;
        p|P) run_init_project ;;
        b|B|q|Q) return ;;
        *) show_install_menu ;;
    esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Tutorial
# ─────────────────────────────────────────────────────────────────────────────
show_tutorial() {
    local file="$KV_HOME/TUTORIAL.md"
    if [ -f "$file" ]; then
        printf "\n ${C_DIM}Opening tutorial... press ${C_CYAN}q${C_DIM} to return${C_RESET}\n"
        sleep 0.3
        # Use glow if available
        if command -v glow &>/dev/null; then
            glow -s dark -p "$file"
        elif [ -x "/opt/homebrew/bin/glow" ]; then
            /opt/homebrew/bin/glow -s dark -p "$file"
        else
            less "$file"
        fi
    else
        draw_header
        printf "\n ${C_RED}Tutorial not found: $file${C_RESET}\n"
        printf " ${C_DIM}Press any key...${C_RESET}"
        read -rsn1
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Docs Menu
# ─────────────────────────────────────────────────────────────────────────────
show_docs_menu() {
    draw_header

    printf "\n"
    printf " ${C_BOLD}${C_WHITE}Documentation${C_RESET}\n"
    printf "\n"
    printf "  ${C_CYAN}1${C_RESET}  Beads            ${C_DIM}Task tracking${C_RESET}\n"
    printf "  ${C_CYAN}2${C_RESET}  Beads Viewer     ${C_DIM}Graph analysis${C_RESET}\n"
    printf "  ${C_CYAN}3${C_RESET}  Agent Mail       ${C_DIM}Multi-agent coordination${C_RESET}\n"
    printf "  ${C_CYAN}4${C_RESET}  CASS             ${C_DIM}Session search${C_RESET}\n"
    printf "  ${C_CYAN}5${C_RESET}  UBS              ${C_DIM}Bug scanner${C_RESET}\n"
    printf "  ${C_CYAN}6${C_RESET}  Warp-Grep        ${C_DIM}Parallel search${C_RESET}\n"

    draw_status_bar "${C_CYAN}b${C_DIM} back"

    read -rsn1 key
    case "$key" in
        1) view_doc "beads/README.md" ;;
        2) view_doc "beads_viewer/README.md" ;;
        3) view_doc "mcp_agent_mail/README.md" ;;
        4) view_doc "coding_agent_session_search/README.md" ;;
        5) view_doc "ultimate_bug_scanner/README.md" ;;
        6) view_doc "warp_grep/README.md" ;;
        b|B|q|Q) return ;;
        *) show_docs_menu ;;
    esac
}

view_doc() {
    local file="$KV_HOME/$1"
    if [ -f "$file" ]; then
        printf "\n ${C_DIM}Opening docs... press ${C_CYAN}q${C_DIM} to return${C_RESET}\n"
        sleep 0.3
        # Check for glow (try PATH first, then homebrew location)
        local glow_cmd=""
        if command -v glow &>/dev/null; then
            glow_cmd="glow"
        elif [ -x "/opt/homebrew/bin/glow" ]; then
            glow_cmd="/opt/homebrew/bin/glow"
        fi

        if [ -n "$glow_cmd" ]; then
            "$glow_cmd" -s dark -p "$file"
        else
            less "$file"
        fi
    else
        printf "\n ${C_RED}File not found: $1${C_RESET}\n"
        printf " ${C_DIM}Docs are at: $KV_HOME${C_RESET}\n"
        printf " ${C_DIM}Press any key...${C_RESET}"
        read -rsn1
    fi
    show_docs_menu
}

# ─────────────────────────────────────────────────────────────────────────────
# Install Functions
# ─────────────────────────────────────────────────────────────────────────────
run_install_full() {
    draw_header
    printf "\n ${C_BOLD}Installing full stack...${C_RESET}\n\n"
    local ts=$(date +%s)

    printf " ${C_DIM}[1/5]${C_RESET} Core (Beads + Viewer + Agent Mail)\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/mcp_agent_mail/main/scripts/install.sh?$ts" | bash -s -- --yes

    printf "\n ${C_DIM}[2/5]${C_RESET} CASS\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_session_search/main/install.sh?$ts" | bash -s -- --easy-mode --verify

    printf "\n ${C_DIM}[3/5]${C_RESET} UBS\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh?$ts" | bash -s -- --easy-mode

    printf "\n ${C_DIM}[4/5]${C_RESET} cass-memory\n"
    # Install Bun if needed
    if ! command -v bun &>/dev/null; then
        curl -fsSL https://bun.sh/install | bash
        export BUN_INSTALL="$HOME/.bun"
        export PATH="$BUN_INSTALL/bin:$PATH"
    fi
    local cm_dir="$KV_HOME/cass_memory_system"
    if [ -d "$cm_dir" ]; then
        (cd "$cm_dir" && git pull)
    else
        git clone https://github.com/Dicklesworthstone/cass_memory_system.git "$cm_dir"
    fi
    (cd "$cm_dir" && bun install && bun run build)
    cp "$cm_dir/dist/cass-memory" ~/.local/bin/cm
    chmod +x ~/.local/bin/cm
    cm init 2>/dev/null || true
    printf " ${C_GREEN}✓ cass-memory installed${C_RESET}\n"

    printf "\n ${C_DIM}[5/5]${C_RESET} MCP Servers (optional API keys)\n"
    printf "\n ${C_BOLD}Exa MCP${C_RESET} ${C_DIM}(AI web/code search)${C_RESET}\n"
    printf " Get key: ${C_CYAN}https://dashboard.exa.ai/api-keys${C_RESET}\n"
    printf " API Key (or 'skip'): "
    read -r exa_key
    if [[ "$exa_key" != "skip" ]] && [[ -n "$exa_key" ]]; then
        claude mcp add exa -s user \
            -e "EXA_API_KEY=$exa_key" \
            -- npx -y exa-mcp-server
        printf " ${C_GREEN}✓ Exa added${C_RESET}\n"
    fi

    printf "\n ${C_BOLD}cass-memory LLM${C_RESET} ${C_DIM}(for auto-reflection)${C_RESET}\n"
    printf " Provider (anthropic/openai/google/skip): "
    read -r llm_provider
    if [[ "$llm_provider" != "skip" ]] && [[ -n "$llm_provider" ]]; then
        printf " API Key: "
        read -r llm_key
        if [[ -n "$llm_key" ]]; then
            local config_file="$HOME/.cass-memory/config.json"
            if [ -f "$config_file" ]; then
                local tmp_file=$(mktemp)
                cat "$config_file" | sed "s/\"provider\": \"[^\"]*\"/\"provider\": \"$llm_provider\"/" > "$tmp_file"
                mv "$tmp_file" "$config_file"
            fi
            printf " ${C_GREEN}✓ Provider set to $llm_provider${C_RESET}\n"
            case "$llm_provider" in
                anthropic) printf " ${C_YELLOW}Add: export ANTHROPIC_API_KEY=\"$llm_key\"${C_RESET}\n" ;;
                openai) printf " ${C_YELLOW}Add: export OPENAI_API_KEY=\"$llm_key\"${C_RESET}\n" ;;
                google) printf " ${C_YELLOW}Add: export GOOGLE_GENERATIVE_AI_API_KEY=\"$llm_key\"${C_RESET}\n" ;;
            esac
        fi
    fi

    printf "\n ${C_GREEN}✓ Full stack installed${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_core() {
    draw_header
    printf "\n ${C_BOLD}Installing core stack...${C_RESET}\n\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/mcp_agent_mail/main/scripts/install.sh?$(date +%s)" | bash -s -- --yes
    printf "\n ${C_GREEN}✓ Done${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_cass() {
    draw_header
    printf "\n ${C_BOLD}Installing CASS...${C_RESET}\n\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_session_search/main/install.sh?$(date +%s)" | bash -s -- --easy-mode --verify
    printf "\n ${C_GREEN}✓ Done${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_ubs() {
    draw_header
    printf "\n ${C_BOLD}Installing UBS...${C_RESET}\n\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh?$(date +%s)" | bash -s -- --easy-mode
    printf "\n ${C_GREEN}✓ Done${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_warpgrep() {
    draw_header
    printf "\n ${C_BOLD}Install Warp-Grep${C_RESET}\n\n"
    printf " Get a free API key: ${C_CYAN}https://morphllm.com/dashboard/api-keys${C_RESET}\n\n"
    printf " API Key (or 'skip'): "
    read -r api_key

    if [[ "$api_key" != "skip" ]] && [[ -n "$api_key" ]]; then
        claude mcp add morph-fast-tools -s user \
            -e "MORPH_API_KEY=$api_key" \
            -e ALL_TOOLS=true \
            -- npx -y @morphllm/morphmcp
        printf "\n ${C_GREEN}✓ Done${C_RESET} ${C_DIM}Restart Claude Code to use${C_RESET}\n"
    else
        printf "\n ${C_DIM}Skipped${C_RESET}\n"
    fi
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_exa() {
    draw_header
    printf "\n ${C_BOLD}Install Exa MCP${C_RESET}\n\n"
    printf " ${C_DIM}AI-powered web search & code context for Claude${C_RESET}\n\n"
    printf " Get API key: ${C_CYAN}https://dashboard.exa.ai/api-keys${C_RESET}\n\n"
    printf " API Key (or 'skip'): "
    read -r api_key

    if [[ "$api_key" != "skip" ]] && [[ -n "$api_key" ]]; then
        claude mcp add exa -s user \
            -e "EXA_API_KEY=$api_key" \
            -- npx -y exa-mcp-server
        printf "\n ${C_GREEN}✓ Done${C_RESET} ${C_DIM}Restart Claude Code to use${C_RESET}\n"
        printf "\n ${C_DIM}Tools added: web_search_exa, get_code_context_exa${C_RESET}\n"
    else
        printf "\n ${C_DIM}Skipped${C_RESET}\n"
    fi
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_install_cass_memory() {
    draw_header
    printf "\n ${C_BOLD}Install cass-memory${C_RESET}\n\n"
    printf " ${C_DIM}Cross-agent procedural memory system${C_RESET}\n"
    printf " ${C_DIM}Requires: Bun runtime${C_RESET}\n\n"

    # Check for Bun
    if ! command -v bun &>/dev/null; then
        printf " ${C_YELLOW}Installing Bun...${C_RESET}\n"
        curl -fsSL https://bun.sh/install | bash
        export BUN_INSTALL="$HOME/.bun"
        export PATH="$BUN_INSTALL/bin:$PATH"
    fi

    local cm_dir="$KV_HOME/cass_memory_system"

    # Clone or update
    if [ -d "$cm_dir" ]; then
        printf " ${C_DIM}Updating cass-memory...${C_RESET}\n"
        (cd "$cm_dir" && git pull)
    else
        printf " ${C_DIM}Cloning cass-memory...${C_RESET}\n"
        git clone https://github.com/Dicklesworthstone/cass_memory_system.git "$cm_dir"
    fi

    # Apply upstream bug fixes (until PRs are merged)
    # See: patches/fix-cass-memory.sh for details and when to remove
    local fix_script="$KV_HOME/patches/fix-cass-memory.sh"
    if [ -f "$fix_script" ]; then
        bash "$fix_script" "$cm_dir"
    fi

    # Build
    printf " ${C_DIM}Building...${C_RESET}\n"
    (cd "$cm_dir" && bun install && bun run build)

    # Install binary
    cp "$cm_dir/dist/cass-memory" ~/.local/bin/cm
    chmod +x ~/.local/bin/cm

    # Initialize
    printf " ${C_DIM}Initializing...${C_RESET}\n"
    cm init 2>/dev/null || true

    printf "\n ${C_GREEN}✓ cass-memory installed${C_RESET}\n"
    printf " ${C_DIM}Command: cm${C_RESET}\n\n"

    # Optional LLM key
    printf " ${C_BOLD}LLM API Key (optional)${C_RESET}\n"
    printf " ${C_DIM}Enables: auto-reflection, smarter context${C_RESET}\n"
    printf " ${C_DIM}Supports: Anthropic, OpenAI, or Google${C_RESET}\n\n"
    printf " ${C_CYAN}1${C_RESET}  Anthropic (recommended)\n"
    printf " ${C_CYAN}2${C_RESET}  OpenAI\n"
    printf " ${C_CYAN}3${C_RESET}  Google\n"
    printf " ${C_CYAN}s${C_RESET}  Skip\n\n"
    printf " Choice: "
    read -rsn1 llm_choice
    printf "\n"

    case "$llm_choice" in
        1)
            printf " Anthropic API Key: "
            read -r api_key
            if [[ -n "$api_key" ]]; then
                # Update config
                local config_file="$HOME/.cass-memory/config.json"
                if [ -f "$config_file" ]; then
                    # Use a temp file for safe editing
                    local tmp_file=$(mktemp)
                    cat "$config_file" | sed 's/"provider": "[^"]*"/"provider": "anthropic"/' > "$tmp_file"
                    mv "$tmp_file" "$config_file"
                fi
                # Set env var hint
                printf "\n ${C_GREEN}✓ Set provider to anthropic${C_RESET}\n"
                printf " ${C_YELLOW}Add to your shell profile:${C_RESET}\n"
                printf "   export ANTHROPIC_API_KEY=\"$api_key\"\n"
            fi
            ;;
        2)
            printf " OpenAI API Key: "
            read -r api_key
            if [[ -n "$api_key" ]]; then
                local config_file="$HOME/.cass-memory/config.json"
                if [ -f "$config_file" ]; then
                    local tmp_file=$(mktemp)
                    cat "$config_file" | sed 's/"provider": "[^"]*"/"provider": "openai"/' > "$tmp_file"
                    mv "$tmp_file" "$config_file"
                fi
                printf "\n ${C_GREEN}✓ Set provider to openai${C_RESET}\n"
                printf " ${C_YELLOW}Add to your shell profile:${C_RESET}\n"
                printf "   export OPENAI_API_KEY=\"$api_key\"\n"
            fi
            ;;
        3)
            printf " Google API Key: "
            read -r api_key
            if [[ -n "$api_key" ]]; then
                local config_file="$HOME/.cass-memory/config.json"
                if [ -f "$config_file" ]; then
                    local tmp_file=$(mktemp)
                    cat "$config_file" | sed 's/"provider": "[^"]*"/"provider": "google"/' > "$tmp_file"
                    mv "$tmp_file" "$config_file"
                fi
                printf "\n ${C_GREEN}✓ Set provider to google${C_RESET}\n"
                printf " ${C_YELLOW}Add to your shell profile:${C_RESET}\n"
                printf "   export GOOGLE_GENERATIVE_AI_API_KEY=\"$api_key\"\n"
            fi
            ;;
        *)
            printf " ${C_DIM}Skipped - cm will run in deterministic mode${C_RESET}\n"
            ;;
    esac

    printf "\n ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

run_init_project() {
    draw_header
    printf "\n ${C_BOLD}Initialize project${C_RESET}\n\n"
    if command -v bd &>/dev/null; then
        bd init
        printf "\n ${C_GREEN}✓ Done${C_RESET}\n"
    else
        printf " ${C_RED}Error:${C_RESET} bd not found. Install core first.\n"
    fi
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_install_menu
}

# ─────────────────────────────────────────────────────────────────────────────
# Create AGENTS.md
# ─────────────────────────────────────────────────────────────────────────────
create_agents_md() {
    if [ -f "AGENTS.md" ]; then
        printf " ${C_YELLOW}AGENTS.md exists.${C_RESET} Overwrite? [y/N] "
        read -rsn1 response
        echo
        [[ ! "$response" =~ ^[Yy]$ ]] && return
    fi

    # Copy from template
    local template="$KV_HOME/AGENTS_TEMPLATE.md"
    if [ -f "$template" ]; then
        cp "$template" AGENTS.md
        printf " ${C_GREEN}✓ Created AGENTS.md from template${C_RESET}\n"
        printf " ${C_DIM}Edit the Project section at the top${C_RESET}\n"
    else
        # Fallback inline template
        cat > AGENTS.md << 'EOF'
# AGENTS.md

## Project
- Name: [Project Name]
- Language: [TypeScript/Python/Go/etc.]

## Session Start
```bash
bd ready --json
bv --robot-priority
cass search "query" --robot --limit 5
bd update <id> --status in_progress
```

## Before Commit
```bash
ubs --staged
ubs --staged --fail-on-warning
```

## Session End
```bash
bd close <id> --reason "Done"
bd sync && git push
```

## Critical Rules
- NEVER run `bv` without `--robot-*` flags
- ALWAYS run `ubs --staged` before commits
- ALWAYS `bd sync && git push` at end
EOF
        printf " ${C_GREEN}✓ Created AGENTS.md${C_RESET}\n"
    fi
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
}

# ─────────────────────────────────────────────────────────────────────────────
# Update Everything
# ─────────────────────────────────────────────────────────────────────────────
show_update() {
    draw_header

    printf "\n"
    printf " ${C_BOLD}${C_WHITE}Update${C_RESET}\n"
    printf "\n"
    printf "  ${C_CYAN}1${C_RESET}  Update all         ${C_DIM}Repos + reinstall binaries${C_RESET}\n"
    printf "  ${C_CYAN}2${C_RESET}  Repos only         ${C_DIM}git pull on all tool repos${C_RESET}\n"
    printf "  ${C_CYAN}3${C_RESET}  Binaries only      ${C_DIM}Reinstall bd, bv, cass, ubs${C_RESET}\n"

    draw_status_bar "${C_CYAN}b${C_DIM} back"

    read -rsn1 key
    case "$key" in
        1) run_update_all ;;
        2) run_update_repos ;;
        3) run_update_binaries ;;
        b|B|q|Q) return ;;
        *) show_update ;;
    esac
}

run_update_repos() {
    draw_header
    printf "\n ${C_BOLD}Updating repositories...${C_RESET}\n\n"

    # Update kv repo itself
    printf " ${C_DIM}[1/6]${C_RESET} knowledge_and_vibes\n"
    cd "$SCRIPT_DIR" && git pull --ff-only 2>/dev/null || printf "   ${C_YELLOW}not a git repo or no remote${C_RESET}\n"

    # Update each tool repo
    local repos=("beads/beads" "beads_viewer/beads_viewer" "mcp_agent_mail/mcp_agent_mail" "coding_agent_session_search/coding_agent_session_search" "ultimate_bug_scanner/ultimate_bug_scanner")
    local names=("Beads" "Beads Viewer" "Agent Mail" "CASS" "UBS")
    local i=0

    for repo in "${repos[@]}"; do
        ((i++))
        printf " ${C_DIM}[$((i+1))/6]${C_RESET} ${names[$i-1]}\n"
        if [ -d "$SCRIPT_DIR/$repo" ]; then
            cd "$SCRIPT_DIR/$repo" && git pull --ff-only 2>/dev/null && printf "   ${C_GREEN}✓${C_RESET}\n" || printf "   ${C_YELLOW}failed${C_RESET}\n"
        else
            printf "   ${C_DIM}not cloned${C_RESET}\n"
        fi
    done

    cd "$SCRIPT_DIR"
    printf "\n ${C_GREEN}✓ Repos updated${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_update
}

run_update_binaries() {
    draw_header
    printf "\n ${C_BOLD}Reinstalling binaries...${C_RESET}\n\n"

    # Cache-bust all URLs with timestamp
    local ts=$(date +%s)

    printf " ${C_DIM}[1/3]${C_RESET} Core (Beads + Viewer + Agent Mail)\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/mcp_agent_mail/main/scripts/install.sh?$ts" | bash -s -- --yes

    printf "\n ${C_DIM}[2/3]${C_RESET} CASS\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_session_search/main/install.sh?$ts" | bash -s -- --easy-mode --verify

    printf "\n ${C_DIM}[3/3]${C_RESET} UBS\n"
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh?$ts" | bash -s -- --easy-mode

    printf "\n ${C_GREEN}✓ Binaries updated${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_update
}

run_update_all() {
    draw_header
    printf "\n ${C_BOLD}Full update...${C_RESET}\n\n"

    # Update repos first
    printf " ${C_BOLD}Step 1: Updating repositories${C_RESET}\n\n"
    cd "$SCRIPT_DIR" && git pull --ff-only 2>/dev/null || true

    local repos=("beads/beads" "beads_viewer/beads_viewer" "mcp_agent_mail/mcp_agent_mail" "coding_agent_session_search/coding_agent_session_search" "ultimate_bug_scanner/ultimate_bug_scanner")
    for repo in "${repos[@]}"; do
        if [ -d "$SCRIPT_DIR/$repo" ]; then
            cd "$SCRIPT_DIR/$repo" && git pull --ff-only 2>/dev/null || true
        fi
    done
    cd "$SCRIPT_DIR"

    # Then reinstall binaries
    printf "\n ${C_BOLD}Step 2: Reinstalling binaries${C_RESET}\n\n"
    local ts=$(date +%s)

    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/mcp_agent_mail/main/scripts/install.sh?$ts" | bash -s -- --yes
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/coding_agent_session_search/main/install.sh?$ts" | bash -s -- --easy-mode --verify
    curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh?$ts" | bash -s -- --easy-mode

    printf "\n ${C_GREEN}✓ Everything updated${C_RESET}\n"
    printf " ${C_DIM}Press any key...${C_RESET}"
    read -rsn1
    show_update
}

# ─────────────────────────────────────────────────────────────────────────────
# Direct Commands (non-interactive)
# ─────────────────────────────────────────────────────────────────────────────
cmd_help() {
    printf "${C_BOLD}kv${C_RESET} - knowledge_and_vibes CLI\n\n"
    printf "Usage: ${C_CYAN}kv${C_RESET} [command]\n\n"
    printf "Commands:\n"
    printf "  ${C_CYAN}kv${C_RESET}            Interactive menu\n"
    printf "  ${C_CYAN}kv install${C_RESET}    Install full stack\n"
    printf "  ${C_CYAN}kv update${C_RESET}     Update repos & binaries\n"
    printf "  ${C_CYAN}kv status${C_RESET}     Check installation\n"
    printf "  ${C_CYAN}kv tutorial${C_RESET}   Show workflow\n"
    printf "  ${C_CYAN}kv init${C_RESET}       Run bd init\n"
    printf "  ${C_CYAN}kv agents${C_RESET}     Create AGENTS.md\n"
    printf "  ${C_CYAN}kv docs${C_RESET}       Browse documentation\n"
    printf "  ${C_CYAN}kv help${C_RESET}       This help\n"
}

cmd_status_direct() {
    check_tools
    printf "${C_BOLD}Status${C_RESET}\n\n"
    printf "$(status_dot $HAS_BD)  bd     "
    [ "$HAS_BD" = "1" ] && printf "${C_GREEN}installed${C_RESET}\n" || printf "${C_RED}missing${C_RESET}\n"
    printf "$(status_dot $HAS_BV)  bv     "
    [ "$HAS_BV" = "1" ] && printf "${C_GREEN}installed${C_RESET}\n" || printf "${C_RED}missing${C_RESET}\n"
    printf "$(status_dot $HAS_CASS)  cass   "
    [ "$HAS_CASS" = "1" ] && printf "${C_GREEN}installed${C_RESET}\n" || printf "${C_RED}missing${C_RESET}\n"
    printf "$(status_dot $HAS_UBS)  ubs    "
    [ "$HAS_UBS" = "1" ] && printf "${C_GREEN}installed${C_RESET}\n" || printf "${C_RED}missing${C_RESET}\n"
    printf "$(status_dot $AM_RUNNING)  mail   "
    [ "$AM_RUNNING" = "1" ] && printf "${C_GREEN}running${C_RESET}\n" || printf "${C_YELLOW}stopped${C_RESET}\n"
}

# ─────────────────────────────────────────────────────────────────────────────
# Main Loop
# ─────────────────────────────────────────────────────────────────────────────
main_loop() {
    while true; do
        show_main_menu
        read -rsn1 key
        case "$key" in
            i|I) show_install_menu ;;
            u|U) show_update ;;
            s|S) show_status ;;
            t|T) show_tutorial ;;
            a|A) create_agents_md ;;
            d|D) show_docs_menu ;;
            q|Q) clear; exit 0 ;;
        esac
    done
}

# ─────────────────────────────────────────────────────────────────────────────
# Entry Point
# ─────────────────────────────────────────────────────────────────────────────
main() {
    case "${1:-}" in
        install) run_install_full ;;
        update) run_update_all ;;
        status) cmd_status_direct ;;
        tutorial) show_tutorial; read -rsn1 ;;
        init) run_init_project ;;
        agents) create_agents_md ;;
        docs) show_docs_menu ;;
        help|--help|-h) cmd_help ;;
        "") main_loop ;;
        *) printf "${C_RED}Unknown: $1${C_RESET}\n"; cmd_help; exit 1 ;;
    esac
}

main "$@"
